{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.translateEndAngle = exports.polarToCartesian = exports.baseUnit = exports.arcCommands = void 0;\nvar POST_DECIMAL_DIGITS = 10;\nvar baseUnit = 24;\nexports.baseUnit = baseUnit;\n\nvar polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\n\nexports.polarToCartesian = polarToCartesian;\n\nvar arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\n\n\nexports.arcCommands = arcCommands;\n\nvar translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};\n\nexports.translateEndAngle = translateEndAngle;","map":{"version":3,"names":["exports","__esModule","translateEndAngle","polarToCartesian","baseUnit","arcCommands","POST_DECIMAL_DIGITS","centerX","centerY","radius","angleInDegrees","angleInRadians","Math","PI","x","cos","y","sin","startAngle","endAngle","normalizedEndAngle","start","end","arcSweep","d","toFixed","join","anglePer","value","max"],"sources":["/Library/WebServer/Documents/MachineLearning/trading/PKT-CASH/LUX/LUXDApp/packages/react-app/node_modules/grommet/utils/graphics.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.translateEndAngle = exports.polarToCartesian = exports.baseUnit = exports.arcCommands = void 0;\nvar POST_DECIMAL_DIGITS = 10;\nvar baseUnit = 24;\nexports.baseUnit = baseUnit;\n\nvar polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\n\nexports.polarToCartesian = polarToCartesian;\n\nvar arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\n\n\nexports.arcCommands = arcCommands;\n\nvar translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};\n\nexports.translateEndAngle = translateEndAngle;"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,iBAAR,GAA4BF,OAAO,CAACG,gBAAR,GAA2BH,OAAO,CAACI,QAAR,GAAmBJ,OAAO,CAACK,WAAR,GAAsB,KAAK,CAArG;AACA,IAAIC,mBAAmB,GAAG,EAA1B;AACA,IAAIF,QAAQ,GAAG,EAAf;AACAJ,OAAO,CAACI,QAAR,GAAmBA,QAAnB;;AAEA,IAAID,gBAAgB,GAAG,SAASA,gBAAT,CAA0BI,OAA1B,EAAmCC,OAAnC,EAA4CC,MAA5C,EAAoDC,cAApD,EAAoE;EACzF,IAAIC,cAAc,GAAG,CAACD,cAAc,GAAG,EAAlB,IAAwBE,IAAI,CAACC,EAA7B,GAAkC,KAAvD;EACA,OAAO;IACLC,CAAC,EAAEP,OAAO,GAAGE,MAAM,GAAGG,IAAI,CAACG,GAAL,CAASJ,cAAT,CADjB;IAELK,CAAC,EAAER,OAAO,GAAGC,MAAM,GAAGG,IAAI,CAACK,GAAL,CAASN,cAAT;EAFjB,CAAP;AAID,CAND;;AAQAX,OAAO,CAACG,gBAAR,GAA2BA,gBAA3B;;AAEA,IAAIE,WAAW,GAAG,SAASA,WAAT,CAAqBE,OAArB,EAA8BC,OAA9B,EAAuCC,MAAvC,EAA+CS,UAA/C,EAA2DC,QAA3D,EAAqE;EACrF;EACA,IAAIC,kBAAkB,GAAGD,QAAzB;EACA;AACF;AACA;AACA;AACA;;EAEE,IAAIA,QAAQ,GAAGD,UAAX,IAAyBC,QAAQ,GAAGD,UAAX,IAAyB,GAAtD,EAA2D;IACzDE,kBAAkB,GAAGF,UAAU,GAAG,MAAlC;EACD;;EAED,IAAIG,KAAK,GAAGlB,gBAAgB,CAACI,OAAD,EAAUC,OAAV,EAAmBC,MAAnB,EAA2BW,kBAA3B,CAA5B;EACA,IAAIE,GAAG,GAAGnB,gBAAgB,CAACI,OAAD,EAAUC,OAAV,EAAmBC,MAAnB,EAA2BS,UAA3B,CAA1B;EACA,IAAIK,QAAQ,GAAGH,kBAAkB,GAAGF,UAArB,IAAmC,GAAnC,GAAyC,GAAzC,GAA+C,GAA9D;EACA,IAAIM,CAAC,GAAG,CAAC,GAAD,EAAMH,KAAK,CAACP,CAAN,CAAQW,OAAR,CAAgBnB,mBAAhB,CAAN,EAA4Ce,KAAK,CAACL,CAAN,CAAQS,OAAR,CAAgBnB,mBAAhB,CAA5C,EAAkF,GAAlF,EAAuFG,MAAM,CAACgB,OAAP,CAAenB,mBAAf,CAAvF,EAA4HG,MAAM,CAACgB,OAAP,CAAenB,mBAAf,CAA5H,EAAiK,CAAjK,EAAoKiB,QAApK,EAA8K,CAA9K,EAAiLD,GAAG,CAACR,CAAJ,CAAMW,OAAN,CAAcnB,mBAAd,CAAjL,EAAqNgB,GAAG,CAACN,CAAJ,CAAMS,OAAN,CAAcnB,mBAAd,CAArN,EAAyPoB,IAAzP,CAA8P,GAA9P,CAAR;EACA,OAAOF,CAAP;AACD,CAlBD;AAmBA;AACA;AACA;AACA;AACA;;;AAGAxB,OAAO,CAACK,WAAR,GAAsBA,WAAtB;;AAEA,IAAIH,iBAAiB,GAAG,SAASA,iBAAT,CAA2BgB,UAA3B,EAAuCS,QAAvC,EAAiDC,KAAjD,EAAwD;EAC9E,OAAOhB,IAAI,CAACiB,GAAL,CAAS,CAAT,EAAYX,UAAU,GAAGS,QAAQ,GAAGC,KAApC,IAA6C,GAApD;AACD,CAFD;;AAIA5B,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B"},"metadata":{},"sourceType":"script"}