{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.shouldKeepFocus = exports.setFocusWithoutScroll = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.isFocusable = exports.getNewContainer = exports.getFirstFocusableDescendant = exports.findVisibleParent = exports.findScrollParents = exports.findScrollParent = exports.containsFocus = void 0;\n\nvar findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n\n  return result;\n};\n\nexports.findScrollParent = findScrollParent;\nvar documentTags = ['html', 'body'];\n\nvar findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    } // last scrollable element will be the document\n\n\n    result.push(document);\n  }\n\n  return result;\n};\n\nexports.findScrollParents = findScrollParents;\n\nvar containsFocus = function containsFocus(node) {\n  var element = document.activeElement;\n\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n\n  return !!element;\n}; // Check if the element.tagName is an input, select or textarea\n\n\nexports.containsFocus = containsFocus;\n\nvar isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n}; // Get the first element that can receive focus\n\n\nexports.isFocusable = isFocusable;\n\nvar getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n\n  return undefined;\n};\n\nexports.getFirstFocusableDescendant = getFirstFocusableDescendant;\n\nvar shouldKeepFocus = function shouldKeepFocus() {\n  var element = document.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\n\nexports.shouldKeepFocus = shouldKeepFocus;\n\nvar getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  } // setup DOM\n\n\n  var container = document.createElement('div');\n\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n\n  return container;\n};\n\nexports.getNewContainer = getNewContainer;\n\nvar setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\n\nexports.setFocusWithoutScroll = setFocusWithoutScroll;\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\n\nvar makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden'); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\nexports.makeNodeFocusable = makeNodeFocusable;\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\n\nvar makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabIndex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\n\nexports.makeNodeUnfocusable = makeNodeUnfocusable;\n\nvar findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\n\nexports.findVisibleParent = findVisibleParent;\n\nvar isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom; // target will be the document from findScrollParent()\n\n\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    height: 0,\n    top: 0\n  },\n      height = _ref.height,\n      top = _ref.top;\n\n  return bottom >= top + height;\n};\n\nexports.isNodeAfterScroll = isNodeAfterScroll;\n\nvar isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top; // target will be the document from findScrollParent()\n\n\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    top: 0\n  },\n      targetTop = _ref2.top;\n\n  return top <= targetTop;\n};\n\nexports.isNodeBeforeScroll = isNodeBeforeScroll;","map":{"version":3,"names":["exports","__esModule","shouldKeepFocus","setFocusWithoutScroll","makeNodeUnfocusable","makeNodeFocusable","isNodeBeforeScroll","isNodeAfterScroll","isFocusable","getNewContainer","getFirstFocusableDescendant","findVisibleParent","findScrollParents","findScrollParent","containsFocus","element","horizontal","result","parent","parentNode","getBoundingClientRect","rect","width","scrollWidth","height","scrollHeight","document","tagName","toLowerCase","documentTags","push","length","includes","node","activeElement","parentElement","children","getElementsByTagName","i","child","undefined","target","targetChildPosition","body","container","createElement","prepend","appendChild","x","window","scrollX","y","scrollY","focus","scrollTo","TABINDEX","TABINDEX_STATE","hasAttribute","removeAttribute","elements","Array","prototype","filter","call","forEach","prior","getAttribute","setAttribute","autoFocusingTags","currentTag","match","offsetParent","_node$getBoundingClie","bottom","_ref","top","_node$getBoundingClie2","_ref2","targetTop"],"sources":["/Library/WebServer/Documents/MachineLearning/trading/PKT-CASH/LUX/LUXDApp/packages/react-app/node_modules/grommet/utils/DOM.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.shouldKeepFocus = exports.setFocusWithoutScroll = exports.makeNodeUnfocusable = exports.makeNodeFocusable = exports.isNodeBeforeScroll = exports.isNodeAfterScroll = exports.isFocusable = exports.getNewContainer = exports.getFirstFocusableDescendant = exports.findVisibleParent = exports.findScrollParents = exports.findScrollParent = exports.containsFocus = void 0;\n\nvar findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n\n  return result;\n};\n\nexports.findScrollParent = findScrollParent;\nvar documentTags = ['html', 'body'];\n\nvar findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    } // last scrollable element will be the document\n\n\n    result.push(document);\n  }\n\n  return result;\n};\n\nexports.findScrollParents = findScrollParents;\n\nvar containsFocus = function containsFocus(node) {\n  var element = document.activeElement;\n\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n\n  return !!element;\n}; // Check if the element.tagName is an input, select or textarea\n\n\nexports.containsFocus = containsFocus;\n\nvar isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n}; // Get the first element that can receive focus\n\n\nexports.isFocusable = isFocusable;\n\nvar getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n\n  return undefined;\n};\n\nexports.getFirstFocusableDescendant = getFirstFocusableDescendant;\n\nvar shouldKeepFocus = function shouldKeepFocus() {\n  var element = document.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\n\nexports.shouldKeepFocus = shouldKeepFocus;\n\nvar getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  }\n\n  // setup DOM\n  var container = document.createElement('div');\n\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n\n  return container;\n};\n\nexports.getNewContainer = getNewContainer;\n\nvar setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\n\nexports.setFocusWithoutScroll = setFocusWithoutScroll;\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\n\nvar makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden'); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\nexports.makeNodeFocusable = makeNodeFocusable;\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\n\nvar makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabIndex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\n\nexports.makeNodeUnfocusable = makeNodeUnfocusable;\n\nvar findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\n\nexports.findVisibleParent = findVisibleParent;\n\nvar isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom; // target will be the document from findScrollParent()\n\n\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    height: 0,\n    top: 0\n  },\n      height = _ref.height,\n      top = _ref.top;\n\n  return bottom >= top + height;\n};\n\nexports.isNodeAfterScroll = isNodeAfterScroll;\n\nvar isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top; // target will be the document from findScrollParent()\n\n\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    top: 0\n  },\n      targetTop = _ref2.top;\n\n  return top <= targetTop;\n};\n\nexports.isNodeBeforeScroll = isNodeBeforeScroll;"],"mappings":"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"},"metadata":{},"sourceType":"script"}